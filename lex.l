%{
#include "parser.tab.h"  /* Include the parser header file generated by Bison */
#include <stdio.h>
%}
%option noyywrap

/* Token definitions */
%%
"if"                { printf("LEXER: Found keyword 'if'\n"); return IF; }
"else"              { printf("LEXER: Found keyword 'else'\n"); return ELSE; }
"int"               { printf("LEXER: Found type 'int'\n"); return INT; }
"float"             { printf("LEXER: Found type 'float'\n"); return FLOAT; }
[a-zA-Z_][a-zA-Z0-9_]*  { printf("LEXER: Found identifier '%s'\n", yytext); return IDENTIFIER; }
[0-9]+              { printf("LEXER: Found integer '%s'\n", yytext); return INTEGER; }
[0-9]*\.[0-9]+      { printf("LEXER: Found float '%s'\n", yytext); return FLOATING; }
"+"                 { printf("LEXER: Found operator '+'\n"); return '+'; }
"-"                 { printf("LEXER: Found operator '-'\n"); return '-'; }
"*"                 { printf("LEXER: Found operator '*'\n"); return '*'; }
"/"                 { printf("LEXER: Found operator '/'\n"); return '/'; }
"="                 { printf("LEXER: Found operator '='\n"); return '='; }
">"                 { printf("LEXER: Found operator '>'\n"); return '>'; }
"<"                 { printf("LEXER: Found operator '<'\n"); return '<'; }
">="                { printf("LEXER: Found operator '>='\n"); return GE; }
"<="                { printf("LEXER: Found operator '<='\n"); return LE; }
"=="                { printf("LEXER: Found operator '=='\n"); return EQ; }
"!="                { printf("LEXER: Found operator '!='\n"); return NE; }
";"                 { printf("LEXER: Found semicolon\n"); return ';'; }
"{"                 { printf("LEXER: Found open brace\n"); return '{'; }
"}"                 { printf("LEXER: Found close brace\n"); return '}'; }
"("                 { printf("LEXER: Found open parenthesis\n"); return '('; }
")"                 { printf("LEXER: Found close parenthesis\n"); return ')'; }
[ \t\n]+            ; /* Ignore whitespace */
.                   { printf("LEXER: Unknown character: %s\n", yytext); }
%%